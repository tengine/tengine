#!/usr/bin/env ruby
# -*- coding: utf-8 -*-
require 'rubygems'
require 'optparse'
require 'daemons'

require File.expand_path('../config/environment', File.dirname(__FILE__))
# require File.expand_path('../app/models/tengine/core/bootstrap', File.dirname(__FILE__))

hash = Tengine::Core::Config.default_hash

ARGV.options do |o|

  o.banner = <<EOS
Usage: tengined [-k action] [-f path_to_config] [-T path/to/file_or_dir]
         [-H db_host] [-P db_port] [-U db_user] [-S db_pass] [-B db_database]
         [-h mq_conn_host] [-p mq_conn_port] [-u mq_conn_user] [-s mq_conn_pass]
         [-v mq_conn_vhost] [-e mq_exchange_name] [-q mq_queue_name]
EOS

  tengine_opt = lambda do |prefixes, base_name, args|
    prefixes = Array(prefixes)
    args = Array(args)
    options = args.last.is_a?(Hash) ? args.pop : {}
    description = args.pop
    short_arg = args.first
    long_arg = "--#{prefixes.join('-')}-#{base_name}".gsub(/_/, '-')
    datasource = prefixes.inject(hash){|d, prefix| d[prefix]}
    if options[:hide_value]
      block = lambda{ datasource[base_name] = true}
    else
      default_value = datasource[base_name]
      long_arg << "=VAL"
      description << " default: #{default_value.inspect}"
      block = lambda{|v| datasource[base_name] = v}
    end
    on_args = [short_arg, long_arg, description].compact
    o.on(*on_args, &block)
  end

  o.separator ""
  o.separator "Basic:"
  o.on("-k", "--action=test|load|start|enable|stop|force-stop|status", "default: start"){|v| hash[:action] = v}
  o.on("-f", "--config=filepath"                , "Specify configuration file path."){|v| hash[:config] = v}

  o.separator ""
  o.separator "Process:"
  {
    :daemon => ["-D", "ignored with \"-k test, -k load, -k enable\".", :hide_value => true],
    :skip_load => ["doesn't load event handler when start. usually use with --daemon option. [only for command]", :hide_value => true],
    :skip_enablement => ["doesn't enable event handler when start. usually use with --daemon option. [only for command]", :hide_value => true],
    :skip_waiting_activation => ["doesn't activate kernel when start. usually use with --daemon option. [only for command]", :hide_value => true],
    :activation_timeout => "period to wait for making activation file.",
    :load_path => ["-T", "[REQUIRED] path/to/file_or_dir. ignored with \"-k test\".", :hide_value => true],
    :log_dir  => "path/to/dir.",
    :pid_dir  => "path/to/dir.",
    :activation_dir => "path/to/dir.",
  }.each{|key, args| tengine_opt.call(:tengined, key, args)}

  o.separator ""
  o.separator "DB Connection:"
  {
    :host     => ["-O", "hostname to connect db."],
    :port     => ["-P", "port to connect db."],
    :username => ["-U", "username to connect db."],
    :password => ["-S", "password to connect db."],
    :database => ["-B", "database name to connect db."],
  }.each{|key, args| tengine_opt.call(:db, key, args)}

  o.separator ""
  o.separator "MQ subscription:"
  {
    :host  => ["-o", "hostname to connect queue server."],
    :port  => ["-p", "port to connect queue server."],
    :vhost => ["-u", "vhost to connect queue server."],
    :user  => ["-u", "username to connect queue server."],
    :pass  => ["-s", "password to connect queue server."],
  }.each{|key, args| tengine_opt.call([:event_queue, :connection], key, args)}


  {
    :name    => ["-e", "exchange name to access to queue."],
    :type    => [     "exchange type to access to queue."],
    :durable => [     "exchange durable to access to queue"],
  }.each{|key, args| tengine_opt.call([:event_queue, :exchange], key, args)}

  {
    :name    => ["-q", "queue name to subscribe."],
    :durable => [     "queue durable to subscribe."],
  }.each{|key, args| tengine_opt.call([:event_queue, :queue], key, args)}

  o.separator ""
  o.separator "Log common options:"
  {
    :output        => ['file path or "STDOUT" / "STDERR"', :hide_value => true],
    :rotation      => ['rotation file count or daily,weekly,monthly.'],
    :rotation_size => ['number of max log file size.'],
    :level         => ['debug/info/warn/error/fatal.'],
  }.each{|key, args| tengine_opt.call(:log_common, key, args)}

  o.separator ""
  o.separator "Application log options:"
  {
    :output        => ['file path or "STDOUT" / "STDERR". default: if daemon process then “./log/application.log" else "STDOUT"', :hide_value => true],
    :rotation      => ['rotation file count or daily,weekly,monthly. default: value of --log-common-rotation', :hide_value => true],
    :rotation_size => ['number of max log file size. default: value of --log-common-rotation-size', :hide_value => true],
    :level         => ['debug/info/warn/error/fatal. default: value of --log-common-level', :hide_value => true],
  }.each{|key, args| tengine_opt.call(:application_log, key, args)}

  o.separator ""
  o.separator "Process STDOUT log options:"
  {
    :output        => ['file path or "STDOUT" / "STDERR". default: if daemon process then “./log/#{$PROGRAM_NAME}_#{Process.pid}_stdout.log" else "STDOUT"', :hide_value => true],
    :rotation      => ['rotation file count or daily,weekly,monthly. default: value of --log-common-rotation', :hide_value => true],
    :rotation_size => ['number of max log file size. default: value of --log-common-rotation-size', :hide_value => true],
    :level         => ['debug/info/warn/error/fatal. default: value of --log-common-level', :hide_value => true],
  }.each{|key, args| tengine_opt.call(:process_stdout_log, key, args)}

  o.separator ""
  o.separator "Process STDERR log options:"
  {
    :output        => ['file path or "STDOUT" / "STDERR". default: if daemon process then “./log/#{$PROGRAM_NAME}_#{Process.pid}_stderr.log" else "STDERR"', :hide_value => true],
    :rotation      => ['rotation file count or daily,weekly,monthly. default: value of --log-common-rotation', :hide_value => true],
    :rotation_size => ['number of max log file size. default: value of --log-common-rotation-size', :hide_value => true],
    :level         => ['debug/info/warn/error/fatal. default: value of --log-common-level', :hide_value => true],
  }.each{|key, args| tengine_opt.call(:process_stderr_log, key, args)}

  o.separator ""
  o.separator "General options:"

  o.on("-h", '--help', "Show this help message."){ puts o; exit}
  o.parse!
end


hash.update(:daemon_proc_path => File.expand_path(__FILE__))

require 'pp'
pp hash

if ["stop", "force_stop"].include? hash[:action]
  pid = Dir.glob(hash[:tengined][:pid_dir] + "/*") do |f|
  end
  result = Process.kill("INT", pid)
else
  daemonize_options = {
    :app_name => "tengined",
    :ARGV => ['start'],
    :dir_mode => :normal,
    :dir => hash[:tengined][:pid_dir],
    :multiple => true,
    :ontop => !hash[:tengined][:daemon],
    :monitor => true,
    :log_dir => hash[:tengined][:log_dir],
    :log_output => false
  }
  daemonize_options = {
    :ontop => !hash[:tengined][:daemon],
    :app_name => "tengined",
    :dir_mode => :normal,
    :dir => hash[:tengined][:pid_dir],
    :log_dir => hash[:tengined][:log_dir],
    :log_output => false
  }
  pp daemonize_options
  # pid_dir, log_dirない場合は
  #Daemons.run_proc("tengined", daemonize_options) do
  Daemons.daemonize(daemonize_options)
    #if hash[:tengined][:daemon]
    #  STDOUT.reopen(File.expand_path(hash[:tengined][:log_dir] + "#{Process.pid}_stdout.log", File.dirname(__FILE__)), "a")
    #  STDERR.reopen(File.expand_path(hash[:tengined][:log_dir] + "#{Process.pid}_stderr.log", File.dirname(__FILE__)), "a")
    #end

    #bootstrap = Tengine::Core::Bootstrap.new(hash)
    loop do
      puts 'in loop'
      sleep 10
    end
    #bootstrap.boot
  #end
end

Signal.trap(:INT){puts ":INT"; exit()}
Signal.trap(:TERM){puts ":INT"; exit()}
